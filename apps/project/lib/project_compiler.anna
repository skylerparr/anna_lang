defmodule(ProjectCompiler, {
  @alias util.Template;

  @const PROJECT_SRC_PATH = 'project/';
  @const ANNA_LANG_SUFFIX = '.anna';
  @const HAXE_SUFFIX = '.hx';
  @const BUILD_DIR = '_build/';
  @const LIB_DIR = 'lib/';
  @const OUTPUT_DIR = '_build/apps/main/';
  @const RESOURCE_DIR = '../apps/project/resource/';
  @const CONFIG_FILE = 'app_config.json';
  @const BUILD_FILE = 'build.hxml';
  @const CLASS_TEMPLATE_FILE = 'ClassTemplate.tpl';
  @const BUILD_TEMPLATE_FILE = 'build.hxml.tpl';
  @const HAXE_BUILD_MACRO_START = '@:build(lang.macros.AnnaLang.';
  @const HAXE_BUILD_MACRO_END = ')';

  @def build_project({String: project_dir}, [Tuple], {
    [@_'ok', old_cwd] = System.get_cwd();
    System.set_cwd(project_dir);
    clean();
    config = get_config();
    handle_config(config);
    System.set_cwd(cast(old_cwd, String));
  });

  @def clean([Atom], {
    result = File.rm_rf(BUILD_DIR);
    result = File.mkdir_p(OUTPUT_DIR);
    @_'ok';
  });

  @def get_config([Tuple], {
    [@_'ok', content] = File.get_content(CONFIG_FILE);
    JSON.parse(content);
  });

  @def handle_config({Tuple: [@_'ok', ["application" => app_name]]}, [Tuple], {
    [@_'ok', files] = gather_source_files(LIB_DIR, {});
    generate_template(cast(files, LList));
    compile_app(cast(app_name, String));
  });

  @def handle_config({Tuple: [@_'error', config]}, [Tuple], {
    System.println('error');
    System.println(config);
    error;
  });

  @def gather_source_files({String: dir, LList: ret_val}, [Tuple], {
    [@_'ok', files] = File.ls(dir);
    result = EEnum.reduce(cast(files, LList), {}, @fn {
      [{String: file, LList: acc}] => {
        fun = @fn{
          [{Atom: @_'true'}] => {
            filename = Str.concat(cast(dir, String), cast(file, String));
            [@_'ok', content] = File.get_content(filename);

            [@_'ok', module_name, module_type] = @native util.AST.getModuleInfo(content);

            content = Str.concat(HAXE_BUILD_MACRO_START, content);
            content = Str.concat(content, HAXE_BUILD_MACRO_END);

            // todo: figure this out
            // src_file = SourceFile%{source_code: content, module_name: module_name, module_type: module_type};
            src_file = ['source_code' => content, 'module_name' => module_name, 'module_type' => module_type];
            @native LList.add(acc, src_file);
            acc;
          };
          [{Atom: @_'false'}] => {
            acc;
          };
        }
        fun(Str.ends_with(file, ANNA_LANG_SUFFIX));
      };
    });
    [@_'ok', result];
  });

  @def generate_template({LList: source_files}, [Tuple], {
    template_file = Str.concat(RESOURCE_DIR, CLASS_TEMPLATE_FILE);
    [@_'ok', template] = File.get_content(template_file);
    [@_'ok', result] = @native Template.execute(template, ['source_files' => source_files]);

    filename = 'Code';
    filename = Str.concat(OUTPUT_DIR, filename);
    filename = Str.concat(filename, HAXE_SUFFIX);

    File.save_content(filename, cast(result, String));

    [@_'ok', result];
  });

  @def compile_app({String: app_name}, [Tuple], {
    //copy the app_config
    app_config_destination = Str.concat(OUTPUT_DIR, CONFIG_FILE);
    File.cp(CONFIG_FILE, app_config_destination);

    //update the haxe build file
    template_file = Str.concat(RESOURCE_DIR, BUILD_TEMPLATE_FILE);
    [@_'ok', template] = File.get_content(template_file);

    [@_'ok', result] = @native Template.execute(template, ["app_name" => app_name]);
    template_file = Str.concat(BUILD_DIR, BUILD_FILE);
    File.save_content(template_file, cast(result, String));

    status = @native util.Compiler.compileProject();
    @native IO.inspect(status);

    [@_'ok', filename, result];
  });
})